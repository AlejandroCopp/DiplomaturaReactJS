
Este archivo de guia fue creado a partir del -----------------------------------------M5U4------------------------------------------------------------------------------------
donde el login ya esta empezado y tenemos previo  
la base de datos armada

Para iniciar el local host en consola ponemos:

npm start

cambiamos del archivo index.js el siguiente codigo

          router.get('/', function(req, res, next) {
            res.render('index', { title: 'Express' }); // se puede poner tambien res.redirect("admin/login")
          });                                           //entonces cuando ente a el "/" que es localhost3000 va a
          ;                                                //redireccionar a admin/login directo 

a este otro 

        router.get('/', function(req, res, next) {
          res.redirect('admin/login');                 //redirecciona a admin/login directo osea que al poner localhost3000 va a admin/login
        });                                         // borramos el express y demas por que 
        ;                                              //cuando trabajamos con redireccionamietno no hay express
        module.exports = router;


cerramos el localhost con Ctrl+C para intalar las dependencias de la base de datos

npm i mysql
npm i util
npm i dotenv   //para trabajar las variables de entorno
npm i express-session
npm i md5                  // encripta la contraseña 


Se pueden ver las dependencias instaladas en  el archivo package.json

vamos a phpmyadmin controlar que este el xamp abierto
y creamos una nueba base de datos
nombre en este caso: ACdesign y utf8_general_ci o similar
cramos tabla usuarios

armar las columnas 
id                         num            primario           autoincrementar
usuario                    varchar
contraseña                 varchar

en la solapa insertar vamos a cargar los datos 
id          no ponemos nada
usuario     Ale                   (Con mayuscula)
contraseña  1234                  aca le ponemos que sea md5 para que encripte

generar otro usuario 


empezamos a armar el login
vamos a login.hbs
y vamos a buscar a la pagina de botstrap algun login ..
el login lo termine creando yo
importante cuando se arma con row
poner en el css que el contenedor tenga 
  display: flex;
  flex-direction: column;
para que los row se pongan uno abajo del otro 

La pantalla login ya esta diseñada en html y css

Es importante que el login en el form, diga 
action="/admin/login" method="post"
y el input del usuario tenga name="usuario"
y el input de la contraseña name="password"
para que despues capturarlo y compararlo con la base

creamos el archivo .env con el nombre de la vase:
        MYSQL_HOST=localhost
        MYSQL_DB_NAME=acdesign
        MYSQL_USER=root
        MYSQL_PASSWORD=

copiamos en app.js el siguiente codigo despues de morgan
        require('dotenv').config();     //este proyecto va a trabajar con variables de entorno

creamos la carpeta models dentro de la misma el bd.js con este codigo:

          var mysql = require('mysql')
          var util = require ('util')

          var pool = mysql.createPool({
              connectionLimit: 10,
              host: process.env.MYSQL_HOST,
              user: process.env.MYSQL_USER,
              password: process.env.MYSQL_PASSWORD,
              database: process.env.MYSQL_DB_NAME,
          });

          pool.query = util.promisify(pool.query);

          module.exports = pool;

todo esto lo hicimos la clase pasada en M5U3

En la carpeta de modelos creamos usuariosModel.js
ponemos el siguiente codigo


    var pool = require('./bd'); //llamado a base de datos
    var md5 = require ('md5'); // era algo de la encriptacion de la contraseña

    async function getUserByUsernameAndPassword(user, password) {                 //es una funcion asyncronica por que no se sabe cuando se va a usar
        try {
            var query = 'select * from usuarios where usuario = ? and password = ? limit 1';
            var rows = await pool.query(query, [user, md5(password)]);
            return rows[0];
        } catch (error) {
            console.log(error);
        }
    }

    module.exports = { getUserByUsernameAndPassword }


en login.js creamos esta variable para acceder a las fucniones del codigo anterior
      var usuariosModel = require('./../../models/usuariosModel'); //nos permite acceder a las funciones que tengamos hechas con la tabla






y luego debajo del codigo que ya hay en login.js ponemos esto:

        router.post('/', async (req, res, next) => {       // a travez del post (la informacion que se esconde en el url) de localhost3000 que direcciona a admin/login
          try {
            var usuario = req.body.usuario; //captura la info de usuario .... lucas
            var password = req.body.password; // captura 1234
            var data = await usuariosModel.getUserByUsernameAndPassword(usuario, password);           //la variable data se conecta con usuariosModel que tiene todas las funciones
            ;                                                                                         //busco la funcion getUserByUsernameAndPassword y le paso lo que esta almacenando en
            ;                                                                                         // las variables usuario y password que obtienen la info del metodo post en '/' 
            ;                                                                                         // la funcion getUserByUsernameAndPassword consulta la base de datos y los trae si son correctos
            ;                                                                                         //await le da el cierre a la funcion asincronica
            if (data != undefined) {                                  //si data es diferente a undefined .... es decir, que tengo un registro 
              res.redirect('/admin/novedades');                       //redirecciona a admin novedades
            } else {
              res.render('admin/login', {                             //si no, hace un render de la pagina de nuevo 
                layout: 'admin/layout',                               // levanta el layout, que es la base estructural de las pag. body footer header, etc.
                error: true
              });
            }
          } catch (error) {
            console.log(error);
          } //cierro catch

        });  //cierro router.post


en login.hbs ponermo el siguiente codigo para que si hay un error muestre el mensaje


        {{#if error}}                                     {{!-- en el caso de error mostrar este p , despues se cierra el if--}}
        <p>Usuario y/o contraseña incorrecto</p>
        {{/if}}

volvemos a levantar el servidor npm start y provamos el login

---Ya funciona el login!---

si ponemos datos de un usuario inexistente lo avisa
si  ponemos datos de un usuario correcto nos lleva a admin/novedades pero 
esta ruta no existe, vamos a crearla :

en app.js ponemos :
          var adminRouter = require('./routes/admin/novedades');      //hace referencia a el js
          app.use('/admin/novedades', adminRouter);      //cuando entre al enlace /admin/novedades levanta adminRouter que a su vez levanta ./routes/admin/novedades que es el js
fijarse bien donde va cada uno

creamos en la carpeta /routes/admin el novedades.js y le ponemos el siguiente codigo 

            var express = require('express');
            var router = express.Router();

            /* GET home page. */
            router.get('/', function (req, res, next) {
              res.render('admin/novedades', {     //novedades.hbs son archivos que cree en la carpeta vista/admin
                layout: "admin/layout"      //layout.hbs ... al parecer se complementan los dos hbs este de layout trae la base de la pagina, es decir el header el footer el body 
              });
            });

            module.exports = router;


despues del js creamos el novedades.hbs en la carpeta views/admin
y le ponemos cualquier cosa en h1 de contenido

En este punto si ponemos el enlace /admin/novedades en la barra de direcciones podriamos acceder salteandonos el sistema de login
para eso tenemos que trabajar con archivos de session

vamos a app.js y creamos una variable de session:
          var session = require ('express-session');              // esto se trabajo en la unidad 4 creo... las variables de sesion retienen una informacion a lo largo de toda la sesion 


          app.use(session({
            secret: 'PW2021awqyeudj',
            cookie: { maxAge: null},
            resave: false,
            saveUninitialized: true
          }))

Este código es para configurar un middleware de sesión en una aplicación Express.js utilizando el paquete express-session. El lenguaje utilizado es JavaScript.

secret: Esta opción es requerida y establece la clave secreta utilizada para firmar la cookie de ID de sesión. Debe ser una cadena difícil de adivinar y mantenerse en secreto.
cookie: Esta opción establece las opciones para la cookie de sesión. En este caso, maxAge se establece en null, lo que significa que la cookie no expirará cuando se cierre el navegador. Sin embargo, esto puede ser un problema de seguridad, ya que permitiría que una sesión activa permanezca abierta indefinidamente, lo que podría permitir que un atacante tome el control de la sesión.
resave: Esta opción controla si se debe volver a guardar la sesión en el almacén de sesiones incluso si la sesión no ha sido modificada durante la solicitud. En este caso, se establece en false, lo que significa que la sesión no se volverá a guardar a menos que se modifique durante la solicitud.
saveUninitialized: Esta opción controla si se debe guardar una sesión sin datos. En este caso, se establece en true, lo que significa que se guardará una sesión incluso si no se ha establecido ningún dato en ella.

Luego este otro:

          secured = async (req, res, next) => {
            try {
              console.log(req.session.id_usuario);
              if (req.session.id_usuario) {
                next();
              } else {
                res.redirect('/admin/login');
              }
            } catch (error) {
              console.log(error);
            }
          }


Este código define una función middleware secured que se utiliza para proteger ciertas rutas o páginas en una aplicación web. La función secured verifica si existe una sesión activa y si el usuario ha iniciado sesión antes de permitir el acceso a la página solicitada.

Aquí hay una explicación de lo que hace cada línea de código:

secured = async (req, res, next) => { ... }: Define la función middleware secured como una función asíncrona con los parámetros req, res y next.
console.log(req.session.id_usuario): Muestra en la consola el valor del ID de usuario almacenado en la sesión actual.
if (req.session.id_usuario) { ... } else { ... }: Comprueba si existe un ID de usuario almacenado en la sesión actual. Si existe, la función next() se llama para continuar con el siguiente middleware o controlador de ruta. De lo contrario, el usuario es redirigido a la página de inicio de sesión.
res.redirect('/admin/login'): Redirige al usuario a la página de inicio de sesión.
console.log(error): Muestra en la consola cualquier error que pueda ocurrir durante la ejecución del middleware.


agreganmos tambien en app.js que haga el secured y en base a eso el adminRouter;

        app.use('/admin/novedades', secured, adminRouter);

El app.use session y el sescured tiene que ir siempre mas arriba que los app.use que tienen las rutas, como el de la linea anterior por ejemplo.

Luego en el login.js tenemos que capturar las variables de sesion y guardarlas agregando las siguientes lineas despues del if

      req.session.id_usuario = data.id;                        //guarda en la variable de sesion, el id
      req.session.nombre = data.usuario;                       //guarda en la variable de sesion, el usuario


--- la ruta admin/novedades ya no es accesible sin estar logueado ! ---


Dentro del res.render de novedades.js ponemos esta linea que genera una propiedad persona con la variable de sesion para poder despues imprimirla en el hbs
      persona: req.session.nombre

en el novedades.hbs ponemos un diseño basico que muestra el dato persona
          
          <div class="container" style="margin-top: 50px;">
        {{!---fila 1 ---}}
        <div class="row">
            <p class="text-end">Hola {{persona}} <a class="btn btn-danger" href="">Cerrar sesion <i class= "fas fa-sign-out-alt"></i></a></p>
        </div>
        {{!--- fin de la fila 1 ---}}

       </div>

Ahora armamos el Log out que se va a manejar por el metodo get
en novedades.hbs colocamos en el href del boton lo siguiente
      href="/admin/login/logout"

Despues vamos a hacer el controlador en login.js

        router.get('/logout', function (req,res,next){
          req.session.destroy(); //destrui la variables de sesion (id y usuario)
          res.render('admin/login', {
            layout: 'admin/layout'
          });
        })

entonces asi si nosotros tocamos log out se borran los datos de sesion, por que
si no una vez que los ingresamos y navegamos por el sitio podriamos cambiar la url y
acceder siempre a admin/novedades 

--------------------------------------------------------------------------M6U1----------------------------------------------------------------------------------------------------------------

En esta unidad vamos a hacer el listado de novedades y el alta de novedades

armamos en novedades.hbs

la tabla:


    {{!---fila 3 ---}}
    <div class="row">
        <div class="col">
            <table class="table">
                <thead>
                    <tr class="table-dark">
                        <th scope="col">#</th>
                        <th scope="col">Titulos</th>
                        <th class="text-end">Acciones</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <th>1</th>
                        <td>Titulo</td>
                        <td class="text-end">
                            <a class="btn btn-secondary" href=""><i class="fa fa-pencil" aria-hidden="true"></i></a>
                            <a class="btn btn-secondary" href=""><i class="fa fa-trash" aria-hidden="true"></i></a>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>


en la base de datos http://localhost/phpmyadmin , recordar tener prendido el xamp

creamos una nueva tabla con los campos id int 11 primario tildar AI, titulo varchar 250, subtitulo text, cuerpo text 

ir a la parte de insertar y cargar los datos de alguna noticia, le ponemos continuar dos veces para que despues borremos una la proxima clase
cargar el titulo subtitulo y cuerpo de otra noticia distinta tambien la cargamos dos veces

chequear que halla 4 novedades en la base 

vamos a crear un nuevo modelo de las acciones contra la tabla de novedades
dentro de models creamos el script novedadesModel.js

          var pool = require ('./bd'); //llamada a la base de datos

          async function getNovedades() {
              var query = 'select * from novedades';   // trae todo de la tabla novedades
              var rows = await pool.query(query);
              return rows;
          }

          module.exports = {getNovedades}

esta funcion vamos a trabajarla en el controlador de novedades... en routes/admin/novedades.js
todos los controladores estan en la carpeta admin.... parece...

agregar 
        var novedadesModel = require('../../models/novedadesModel');

combertir la funcion en asincronica con async como en los usuarios por que no 
se sabe cuando se va a usar es funcion, si no node se queda pensando

        router.get('/', async function (req, res, next) {

dentro del res.render le pasamos novedades quedaria asi:

          res.render('admin/novedades', {   
            layout: "admin/layout",      
            persona: req.session.nombre,
            novedades
          });
        });


Revisamos como se usa el #each en la pagina handlebarsjs.com

en novedades.hbs encerramos en un #each el tr y reemplazamos el contenido estatico por el contenido de la base de datos en {{}} que es el dinamico


    {{!---fila 3 ---}}
    <div class="row">
        <div class="col">
            <table class="table">
                <thead>
                    <tr class="table-dark">
                        <th scope="col">#</th>
                        <th scope="col">Titulos</th>
                        <th class="text-end">Acciones</th>
                    </tr>
                </thead>
                <tbody>
                    {{#each novedades}}
                    <tr>
                        <th scope="row">{{id}}</th>
                        <td>{{titulo}}</td>
                        <td class="text-end">
                            <a class="btn btn-secondary" href=""><i class="fa fa-pencil" aria-hidden="true"></i></a>
                            <a class="btn btn-secondary" href=""><i class="fa fa-trash" aria-hidden="true"></i></a>
                        </td>
                    </tr>
                    {{/each}}
                </tbody>
            </table>
        </div>
    </div>


con esto la tabla queda dinamica, rellenada con las cosas que vimos en la base de datos

ahora vamos a hacer el alta de noticias, haciendo click en el boton verde deberia aparecer en el formulario

vamos a novedades.hbs y a el boton success le agregamos el href 

            <a class="btn btn-success" href="/admin/novedades/agregar">

la palabra agregar es la que vamos a poner despues en el controlador

en novedades.js agregamos:

              router.get('/agregar', (req, res, next) => {          // cuando se reciba a travez del metodo get la barra localhost3000/admin/novedades/agregar 
                res.render('admin/agregar',{                        // traeme un render de admin con el layout
                  layout: 'admin/layout'
                })
              });


Cremos un agregar.hbs para crear la vista
este tiene el formulario:


            <div class="container" style="margin:100px auto">
                <div class="row">
                    <div class="col-6 offset-3">
                        <h4>Agregar una nueva novedad</h4>
                        <form action="/admin/novedades/agregar" method="post">                   {{! la accion es para hacer despues a travez del metodo post}}
                        <div class="mb-3 row">                                                   {{! cuando reciba router.post/agregar va a pasar algo}}
                            <input type="text" class="form-control" placeholder="Titulo" name="titulo">    {{!me voy a llevar el name del titulo}}
                        </div>
                        <div class="mb-3 row">
                            <textarea type="text" class="form-control" placeholder="Subtitulo" name="subtitulo"></textarea>    {{!me voy a llevar el name del subtitulo}}
                        </div>
                        <div class="mb-3 row">
                            <textarea type="text" class="form-control" placeholder="Cuerpo" name="cuerpo"></textarea>    {{!me voy a llevar el name del cuerpo}}
                        </div>
                        <button type="submit" class="btn btn-primary">Guardar</button>           {{! el boton es del tipo="enviar" por mas que se un input no esta de mas aclararlo}}
                        </form>
                          {{#if error}}
                                 <p>
                                    {{message}}                                                                              {{!propiedad message}}
                                </p>
                          {{/if}}
                    </div>
                </div>
            </div>


ahora hay que decirle la query cual va a ser 

vamos a novedadesModel.js


          async function insertNovedades(obj) {
              try {
                  var query = "insert into novedades set ?";
                  var rows = await pool.query(query, [obj])
                  return rows;

              } catch (error) {
                  console.log(error);
                  throw error;
              }
          }

module.exports = {getNovedades, insertNovedades}


vamos a novedades.js y ponemos :



                          router.post('/agregar', async (req, res, next) => {
                            try {
                              console.log(req.body)
                              if (req.body.titulo != "" && req.body.subtitulo != ""  && req.body.cuerpo != "") {            //chequeo que tenga informacion en cada campo , si esta vacio 
                                await novedadesModel.insertNovedades(req.body);                                           //comunicate con las novedades y busca la funcion de insertar y le paso los elementos req.body
                                                                                                                          //req.body seria el objeto que tiene los datos
                                res.redirect('/admin/novedades')                                                          // si esta todo ok redireccionamelo 
                              } else {                                                                                    // si no, vuelve a agregar y tira el error "todos los campo son requeridos"
                                res.render('admin/agregar', {
                                  layout: 'admin/layout',
                                  error: true,
                                  message: 'Todos los campos son requeridos'
                                })
                              }
                            } catch (error) {                                                                            // esto es por si hay un error al conectar con la base
                              console.log(error)
                              res.render('admin/agregar', {
                                layout: 'admin/layout',
                                error: true,
                                message: 'No se creo la novedad'
                              })
                            }
                          })


Con esto ya deberia tener la fucion de error cuando algun campo del form esta vacio y error tambien cuando no se puede conectar con la base de datos



--------------------------------------------------------------------------M6U2----------------------------------------------------------------------------------------------------------------

Eliminar novedades y modificar novedades


en novedades.hbs vamos a poner el href a el boton Eliminar dando como parametro tambien el id despues de la ruta
entonces va a tomar el id y va a hacer la accion de eliminar en el correspondiente id

                      <a class="btn btn-secondary" href="/admin/novedades/eliminar/{{id}}"><i class="fa fa-trash" aria-hidden="true"></i></a>


despues en novedadesModel.js  y creamos el nuevo modelo que va a interactuar con la base de datos

                      
                    async function deleteNovedadesById(id) {
                        var query = 'delete from novedades where id = ?';
                        var rows = await pool.query(query, [id]);
                        return rows; 
                    }

agregamos tambien en el export la funcion 

                       module.exports = {getNovedades, insertNovedades, deleteNovedadesById}

el controlador (novedades.js) va a tomar el id para despues poder pasarselo a la funcion


                  /* eliminar */

                  router.get ('/eliminar/:id', async (req, res, next) => {                                      //a trevez del get por que tengo un boton, cuando reciba /eliminar/id
                    var id = req.params.id;                                                                      // genero una variable y con req.params.id caputrp
                    await novedadesModel.deleteNovedadesById(id);                                               //me conecto con la variable y la funcion de borrar y le paso el id
                    res.redirect('/admin/novedades');                                                             //una vez que esta hace un redireccionamiento a novedades 

                  });


ahora vamos a hacer que el boton de modificar funcione ....

                            <a class="btn btn-secondary" href="/admin/novedades/modificar/{{id}}"><i class="fa fa-pencil" aria-hidden="true"></i></a>

por un lado tenemos el diseño
la queri que necesitamos: que traiga un select todos los campos, el nombre de la tabla, y el id que sea igual al que yo mande 
cuando apreto el boton de guardar va a ser una segunda queri 



primero un diseño con la queri cargada

en novedadesModel.js

            async function getNovedadById(id) {
                var query = 'select * from novedades where id = ?' ;
                var rows = await pool.query (query, [id]);
                return rows[0];
            }

y agregamos la funcion getNovedadById a el exports como las demas funciones


traeme el novedades.hbs
en novedades.js ponemos



              /* la vista del form de modificar */

              router.get ('/modificar/:id', async (req, res, next) => {                                           //cuando se recibe la ruta modificar/id
                var id = req.params.id;                                                                           // traeme la variable
                console.log(req.params.id);                                                                       //chequea que traiga el id
                var novedad = await novedadesModel.getNovedadById(id);                                            // guarda en la variable el resultado de la funcion a la que se le paso el id
                
                console.log(req.params.id);                             
                res.render('admin/modificar',{                                                                    // la nueva vista es modificar
                  layout: 'admin/layout',                                                                          // con el layout que venimos trabajando 
                  novedad                                                                                        // pasa novedad al render, para que lo imprima en los imput y text areas
                })
              })



en modificar.hbs ponemos la vista de lo que seria el formulario 

          <div class="container" style="margin:100px 0">
              <div class="row">
                  <div class="col-6 offset-3">
                      <h4>Modificar la novedad</h4>
                      <form action="/admin/novedades/modificar" method="post">                                            {{! esto es lo que captura los datos}}
                          <input type="hidden" value="{{novedad.id}}" name="id">                                                  {{! Este campo es oculto por que es el que contiene el id}}                                
                          <div class="form-grup">
                              <label for="">Titulo</label> 
                              <input type="text" class="form-control" name="titulo" value="{{novedad.titulo}}">                   {{! en los imput añadimos el valor}}
                          </div>
                          <div class="form-grup">
                              <label for="">Subtitulo</label> 
                              <input type="text" class="form-control" name="subtitulo" value="{{novedad.subtitulo}}">
                          </div>
                          <div class="form-grup">
                              <label for="">Cuerpo</label> 
                              <textarea name="cuerpo" class="form-control">{{novedad.cuerpo}}</textarea>                         {{! en el text area el valor lo ponemos en el medio del text area}}
                          </div>
                          <button type="submit" class="btn btn-primary">Modificar</button>
                      </form>
                  </div>
              </div>
          </div>



cuando apreto el boton a travez del metodo post la query va a hacer el update , va a mandar lo que pasa en el titulo, en el subtitulo, en el cuerpo
hay que hcer otra query  que va a tener que ver con el update , va a decrir "che modificame lo que yo te mande de este id"

en novedadesModel.js
            
        async function modificarNovedadById(obj, id){                                                         // objeto por que es un array, voy a recibir titulo, subtitulo y cuerpo
            try{
                var query = 'update novedades set ? where id=?';                                              //modificame todos esos valores, set, 
                var rows = await pool.query(query, [obj, id]);
                return rows;
            } catch (error) {
                throw error;
            } 
        }

y el export con la funcion anterior y esta, nos queda asi :

        module.exports = {getNovedades, insertNovedades, deleteNovedadesById, getNovedadById, modificarNovedadById}

Ya tenemos la nueva query y la tenemos que conectar, es decir cuando haga click en el boton moficar va a recibir /modificar a travez del metodo post y lo tiene que hacer el controlador



en novedades.js

            /* para modificar la novedad */

            router.post('/modificar', async (req, res, next) => {                                           //cuando recibo a travez del metodo post el /modificar
              try{
                var obj = {                                                                                 // capturo los datos
                  titulo: req.body.titulo,                                                                  //como hicimos en la clase de node esto de pasar los datos
                  subtitulo: req.body.subtitulo,                                                            // y en el agregar
                  cuerpo: req.body.cuerpo
                }
                console.log(obj)
                console.log(req.body.id) 

                await novedadesModel.modificarNovedadById(obj, req.body.id);                                // me voy a modificar y me paso el objeto y tambien el id
                res.redirect('/admin/novedades');

              }catch (error) {
                console.log(error)
                res.render('admin/modificar',{
                  layout: 'admin/layout',
                  error: true,
                  message: 'No se modifico la novedad'
                })
              }
            })



En modificar.hbs debajo del form ponemos

            {{#if error}}
            <p>{{message}}</p>
            {{/if}}







--------------------------------------------------------------------------M6U3----------------------------------------------------------------------------------------------------------------

En esta unida vamos a agregar imagenes y


agregamos en la terminal , con el servidor apagado ! , las siguientes dependencias

npm i cloudinary
npm i express-fileupload


Hacemos una cuenta en cloudinary y copiamos del dashboard el API enviroment variable

y pegamos en el archivo env

        MYSQL_HOST=localhost
        MYSQL_DB_NAME=acdesign
        MYSQL_USER=root
        MYSQL_PASSWORD=

        CLOUDINARY_URL=cloudinary://611231686333788:QqCpjTHph1dUzBVdOoRpX8I8UHY@dvkg9erut



en app.js debajo de morgan ponemos

        var fileUpload = require('express-fileupload');

y debajo del cierre del secured ponemos 


        app.use(fileUpload({                                   // como se genera la subida, como se genera ese archivo temporal
          useTempFiles: true,                                     
          tempFileDir: '/tmp/'
        }));

Ahora necesitamos generarle ese campo a la tabla de novedades
vamos a la base de datos en phpmyadmin, entramos a la tabla de novedades, en estructura, generamos un campo "agregar -1- columna -despues del cuerpo-" tocamos continuar

nombre = img_id
tipo = varchar
longitud = 250
nulo = tildado    // da la posibilidad de que no tenga imagen la novedad 

le damos guardar 

vamos a modificar el formulario de agregar para que cuando haga la prueba y suba osea agregue una nueva novedad ya me guarde la imagen

en agregar.hbs le agregamos este parametro al form
               
                    enctype="multipart/form-data"> 

despues el agregamos al form un imput que reciba imagenes
entre medio del div de subtitulo y el div de cuerpo

            <div class="mb-3 row">
                <label> Imagen: <input type="file" class="form-control" name="imagen" id="imagen" /></label>
            </div>


en novedades.js vamos a agregar varias dependencias

var util = require('util');
var cloudinary = require('cloudinary').v2;
const uploader = util.promisify(cloudinary.uploader.upload);


tambien colocamos despues del siguiente router post

         router.post('/agregar', async (req, res, next) => {
                 try {

 esto 

                    var img_id = '';                                             //es para que inicie vacio
                    if (req.files && Object.keys(req.files).length > 0) {         // si hay un archivo y si tiene un nombre osea es mayor a cero 
                      imagen = req.files.imagen;                                  // a la variable imagen  le voy a pasar lo que yo capture
                      img_id = (await uploader (imagen.tempFilePath)).public_id;               //guarda la variable imagen en cloudinary y genera el public id 
                    }       


vamos a insertar las novedades , pasandolas como propiedades ...req.boy y img_id


                if (req.body.titulo != "" && req.body.subtitulo != ""  && req.body.cuerpo != "") {            //chequeo que tenga informacion en cada campo , si esta vacio 
                  await novedadesModel.insertNovedades({
                    ...req.body,                                                                              //traigo lo que pasa en titulo subtitulo y cuerpo. esto lo vimos en la clase de java script
                      img_id                                                                                        //le sumo... si tengo imagen o no
                  });           


provamos cargar una imagen al formulario en la pagina! Ya funciona !


Ahora vamos a el diseño para que se vea la imgen en la tabla 
en novedades.hbs
agregamos un col imagen 
y un td imagen

        {{!---fila 3 ---}}
        <div class="row">
            <div class="col">
                <table class="table">
                    <thead>
                        <tr class="table-dark">
                            <th scope="col">#</th>
                            <th scope="col">Titulos</th>
                            <th scope="col">Imagen</th>
                            <th class="text-end">Acciones</th>
                        </tr>
                </thead>
                <tbody>
                    {{#each novedades}}
                    <tr>
                        <th scope="row">{{id}}</th>
                        <td>{{titulo}}</td>
                        <td>imagen</td>


  necesitamos que el controlado interprete que hay una imagen y que la devuelva para poderla imprimir   en un {{imagen}} dentro del hbs

vamos ahora al controlador novedades.js
y en el routerget ponemos :

            router.get('/', async function (req, res, next) {     // se hace async por que no se sabe cuando se va a usar.... aca recibe localhost3000/admin/novedades

              var novedades = await novedadesModel.getNovedades(); // para que cuando hace la salida se comunique con novedadesModel y me traiga getNovedades 

              novedades = novedades.map(novedad => {                                  //map genera un nuevo array, por que ahora necesitamos devolver 2 cosas la novedad y la imagen
                if (novedad.img_id) {                                                 //chequea si la novedad tiene la imagen_id
                  const imagen = cloudinary.image(novedad.img_id, {                     //si tiene la trae de cloudinary
                    width: 100,                                                          //con estas propiedades
                    height: 100,
                    crop: 'fill'
                  });
                  return {
                    ...novedad,
                    imagen
                  }
                } else {
                  return {
                    ...novedad,
                    imagen: ''
                  }
                }
              })



vamos a novedades.hbs y reemplazamos la palabra imagen estatica por la dinamica 

                        <td>{{{imagen}}}</td>

Ya se ve la imagen en la tabla!!!!!!!!
ahora queda modificar y eliminar

vamos a modificar.hbs
ponemos como atributo del form lo siguiente    

                  enctype="multipart/form-data">

y entre los div de subtitulo y cuerpo ponemos:


                    <div class="mb-3 row">
                        <p>
                            <label>Imagen: <input type="file"
                            class="form-control" name="imagen" id="imagen">
                            </label>
                        </p>
                        <p>
                            <label><input type="checkbox" name="img_delete"
                            id="img_delete" value="1">
                            Eliminar imagen actual?</label>
                            <input type="hidden" name="img_original" value="{{novedad.img_id}}">
                        </p>

                    </div>

  que es la vista de la carga de la imagen en el form modificar

  vamos a el controlador novedades.js

  agregamos abajos del const upload:
  const destroy = util.promisify(cloudinary.uploader.destroy);

le ponemnos el control de lo qe pasa si apretamos o no el check (borra o no la imagen) y en el var obj agregamos img_id



                            router.post('/modificar', async (req, res, next) => {                                           //cuando recibo a travez del metodo post el /modificar
                              try{

                                  let img_id = req.body.img_original;

                                  let borrar_img_vieja = false;

                                  if (req.body.img_delete === "1") {                        //si recibo esto el check apretado ,el id pasa a estar null y habilito para borrar la imagen
                                    img_id = null;
                                    borrar_img_vieja = true;
                                  } else {
                                    if (req.files && Object.keys(req.files).length > 0) {        //si recibo el cheque no apretado
                                      imagen = req.files.imagen;                                    //captura la imagen 
                                      img_id = (await uploader(imagen.                                    //sube la nueva imagen
                                        tempFilePath)).public_id;
                                        borrar_img_vieja = true;                                            //habilita el borrar imagen
                                    }
                                  }
                                  if (borrar_img_vieja && req.body.img_original) {                        //si el primer if se da, va a funcionar este que va a destruir la imagen
                                    await (destroy(req.body.img_original));
                                  }



                                var obj = {                                                                                 // capturo los datos
                                  titulo: req.body.titulo,                                                                  //como hicimos en la clase de node esto de pasar los datos
                                  subtitulo: req.body.subtitulo,                                                            // y en el agregar
                                  cuerpo: req.body.cuerpo,
                                  img_id



YA funciona modificar y eleminar la imagen!!! de la tabla, de la base y de cloudinari
ahora el problema es qeu si elimino la novedad la imagen no se borra de cloudinari


en novedades.js 

en deajo del router get eliminar y la var ponemos :


                /* eliminar una novedad */

                router.get ('/eliminar/:id', async (req, res, next) => {                                      //a trevez del get por que tengo un boton, cuando reciba /eliminar/id
                  var id = req.params.id;                                                                      // genero una variable y con req.params.id caputrp
                  
                  let novedad = await novedadesModel.getNovedadById(id);                                            //obtenemos la novedad por el id 
                  if (novedad.img_id) {                                                                               //si la novedad tiene una imagen la destruye
                    await (destroy(novedad.img_id));
                  }


Listo ya se borra la imagen de cloudinari cuando borramos la noticia

Ahora Comenzamos con el tema API
instalamos una dependencia nueva 
para que cuando armemos la nueva pagina que va a tener que ver con /API donde va a ir tomando react la informacion que 
necesite por que se la va a devolver en formato jason por uqe Js lo interpreta y lo puede imprimir en la pagina

con el servidor apagado

        npm i cors

prendemos el servidor

en app.js ponemos un var

          var cors = require ('cors');

y agregamos la ruta

          var apiRouter = require('./routes/api');

y agregamos

          app.use('/api', cors(), apiRouter);                         //cors para que pueda recibir los datos

creamos el archivo api.js


              var express = require('express');
              var router = express.Router();
              var novedadesModel = require('./../models/novedadesModel'); 
              var cloudinary = require('cloudinary').v2;


              router.get('/novedades', async function (req, res, next) {
                  
                  let novedades = await novedadesModel.getNovedades();
                
                  novedades = novedades.map(novedades => {
                      if (novedades.img_id) {
                          const imagen = cloudinary.url(novedades.img_id, {
                              width: 960,
                              height: 200,
                              crop: 'fill'
                            });
                          return {
                              ...novedades,
                              imagen
                              }
                      } else {
                          return {
                              ...novedades, 
                              imagen: ''
                          }
                      }
                  });

                
                  res.json(novedades);       //la respuesta va a ser un jason 
              });
              module.exports = router;




AHORA VAMOS A TRAER EL FRONT!!!!!!!!!!!!!!


